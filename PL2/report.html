<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Report 2007</title><link href="./css/default.css" rel="stylesheet" type="text/css"><link href="./css/W3C-REC.css" rel="stylesheet" type="text/css"> <style type="text/css"></style><script type="text/javascript" src="chrome-extension://bfbmjmiodbnnpllbbbfblcplfjjepjdn/js/injected.js"></script></head><body><hr><h1>Report 2007</h1><h2>Vamos escrever relatórios</h2><h3><u>Authors:</u></h3><table border="2" class="selectorsReview"><thead><tr><th>Name</th><th>Number</th><th>Email</th></tr><thead><tbody><tr><td>Serafim Pinto</td><td>61056</td><td>a61056@alunos.uminho.pt</td></tr><tr><td>Daniel Araújo</td><td>61058</td><td>a61058@alunos.uminho.pt</td></tr><tr><td>Daniel Carvalho</td><td>61008</td><td>a61008@alunos.uminho.pt</td></tr></tbody></table><h3><u>Date: </u></h3><script>var mydate=new Date()
var year=mydate.getYear()
if (year < 1000)
year+=1900
var day=mydate.getDay()
var month=mydate.getMonth()
var daym=mydate.getDate()
if (daym<10)
daym="0"+daym
var dayarray=new
Array("Domingo","Segunda-Feira","Terça-Feira","Quarta-Feira","Quinta-Feira","Sexta-Feira","Sábado")
var montharray=new
Array("Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro")
document.write(""+dayarray[day]+", "+daym+" de "+montharray[month]+" de "+year+"</b></font></small>")
</script>
<h3><u>Institution:</u> Universidade do Minho</h3><div style="text-align:center;">- yacc -- flex -- PL -- LEI -- Engenharia -- Informatica -</div><div><hr><h1>Abstract</h1><p> Este relatório descreve o processo de desenvolvimento e o resultado obtido, como consequência da resolução do enunciado do trabalho prático número dois da Unidade Curricular Processamento de Linguagens. O enunciado aqui resolvido é sobre o "Report 2007: vamos escrever relatórios". Este documento trata de analisar e explicar os objectivos deste segundo trabalho. Assim, falaremos das decisões tomadas, os principais obstáculos encontrados e os resultados obtidos. Para além dos conhecimentos que já eram necessários para o primeiro projecto, foi necessário demonstrar conhecimentos sobre ferramentas <i>Flex e Yacc</i> , conhecimentos estes que se mostraram muito úteis e interessantes. </p></div><hr><h1>Aknowledgements</h1><p> Agradecer a Deus por tudo. </p><hr><h2>Table of Contents</h2><p><a href="#Introdução">Introdução<a/></p>
<p><a href="#Descrição das ferramentas utililizadas">Descrição das ferramentas utililizadas<a/></p>
<p><a href="#Descrição da Linguagem desenvolvida">Descrição da Linguagem desenvolvida<a/></p>
<p><a href="#Especificação do FLEX">Especificação do FLEX<a/></p>
<p><a href="#Utilização do YACC">Utilização do YACC<a/></p>
<p><a href="#Estruturas na linguagem C">Estruturas na linguagem C<a/></p>
<p><a href="#Geração de Relatórios - Latex e Html">Geração de Relatórios - Latex e Html<a/></p>
<p><a href="#Makefile e Manpage">Makefile e Manpage<a/></p>
<p><a href="#Conclusão">Conclusão<a/></p>
<hr><h1><a name="Introdução">Introdução</a></h1><p> Pretende-se com este segundo trabalho usar o conhecimento adquirido nas aulas teóricas e práticas, sobretudo o uso das ferramentas Flex -  <i>The Fast Lexical Analyzer e Yet Another Compiler Compiler</i> que estão na base do desenvolvimento do nosso trabalho </p><p> Assim sendo, temo como finalidade o desenvolvimento de um compilador que aceitará relatórios escritos numa determinada linguagem e gerará a respectiva versão HTML e gerar também uma versão em \LaTeX. </p><p> À primeira vista, este trabalho pareceu-nos bastante interessante uma vez que, teremos que desenvolver um compilador que gera outra linguagem e estudar o seu funcionamento, e de todos os elementos do grupo esta é a primeira vez que qualquer um de nós fez algo parecido. Para além disto, as ferramentas que devemos utilizar ( <i>Flex e Yacc</i> ) parecem-nos bastantes poderosas e com muitas potencialidades e não temos dúvidas que o facto de as sabermos usar se irá revelar muito benéfico. </p><hr><h1><a name="Descrição das ferramentas utililizadas">Descrição das ferramentas utililizadas</a></h1><p> Para o desenvolvimento deste projecto necessitamos de utilizar ferramentas diferentes, sendo elas o <b>Flex, o Yacc</b> , a linguagem C e a biblioteca glib. </p><p> Assim, os dois primeiros componentes, como já foi referido, tratam-se de um analisador léxico e de um analisador sintáctico, respectivamente. Estes dois são utilizados, maioritariamente, em conjunto, isto é, o Yacc usa uma gramática formal de modo a analisar sintacticamente cada entrada enquanto que o Flex consegue fazer a distinção das expressões regulares. Estas expressões regulares distinguidas pelo Flex são reconhecidos como tokens pelo Yacc. O GCC, popular compilador da linguagem de programação C, é utilizado de modo a combinar o analisador léxico com o analisador sintáctico. A biblioteca glib do C, foi usada nas nossas estruturas de dados como se poderá ver mais adiante. </p><p> Falta fazer uma pequena referência ao uso de LaTeX e HTML que foram gerados pelo compilador, com o objectivo de poder obter um relatório escrito nestas duas linguagens. </p><hr><h1><a name="Descrição da Linguagem desenvolvida">Descrição da Linguagem desenvolvida</a></h1><p> A nossa linguagem é baseada no esboço dado no enunciado, apenas com algumas coisas adicionais sugeridas pelo professor. </p><div style="text-align:center;"><figure><img src="images/report.png" name="Report"><figcaption>Report</figcaption></figure></div><p> O nosso relatório estará dividido em três partes. No que diz respeito ao  <b>FrontMatter</b> acrescentamos todos os não-terminais propostos no enunciado: Subtitle, Institution, Keywords, Aknowledgements, Table of contents, Table of figures e Table of tables. </p><div style="text-align:center;"><figure><img src="images/frontmatter.png" name="Frontmatter"><figcaption>Frontmatter</figcaption></figure></div><ul><li>Subtitle - Apenas texto normal.</li><li>Institution - Apenas texto normal.</li><li>Keywords - Uma lista de palavras-chave do documento</li><li>Aknowledgements - Uma lista de parágrafos tal como o Abstract.</li><li>Tablex of contents - É um inteiro que indica se o relatório conterá os índices respectivos.</li></ul><p> Por exemplo, cada vez que quisermos adicionar um autor ao nosso relatório, basta escrever BAUTHOR. 	E de seguida adicionar os campos acima definidos na estrutura. Na nossa linguagem apenas é obrigatório sempre que se inicia o BAUHTOR, adicionar o nome(BNAME João ENAME). A seguir, a parte principal do relatório que conterá o nosso Body: </p><div style="text-align:center;"><figure><img src="images/body.png" name="Body"><figcaption>Body</figcaption></figure></div><p> O Body será constituído por uma lista de Chapters, e estes terão um Title e uma ElemList. Estes elementos aqui presentes como podemos ver na imagem, podem ser várias coisas: uma imagem, uma tabela, uma section, etc.  Um parágrafo é uma lista de vários elementos, desde o texto até palavras em itálico ou negrito por exemplo. Para começar um parágrafo basta escrever "BPARA" e lá dentro inserir qualquer um dos elementos apresentados acima, iniciados respectivamente pela etiqueta. Outro tipo de elementos dentro do body podem ser as figuras e tabelas que serão iniciadas como BFIGURE, e BTABLE.  </p><p> Resumindo, o nossa linguagem é o esboço feito pelo professor, com mais algumas modificações que a tornam mais completa. De certo modo achamos que o que estava no enunciado era suficiente para tornar um relatório completo e usável. A nosso ver, não havia nada a faltar para acrescentar melhorias na linguagem. </p><table border=2 class="selectorsReview" style="margin-left:auto; margin-right:auto; padding-top:25px;padding-bottom:25px;"><tr><td>Dados</td><td>Mais dados</td><td>Teste</td></tr><tr><td>MAis dados</td><td>TESTE</td><td>TESTE2</td></tr><tr><td>AInda mais dados</td><td>para variar</td><td>ok</td></tr><tr><td>amostra</td><td>amostra2</td><td>amostra4</td></tr><caption><a name="Legenda">Legenda</a></caption></table><hr><h1><a name="Especificação do FLEX">Especificação do FLEX</a></h1><p> Quanto ao prodecimento a desenvolver para tratar da análise lexical, achámos necessário definir quatro estados como fizemos anteriormente no primeiro trabalho prático: </p><div style="text-align:center;"><figure><img src="images/keywords.png" name="Keywords"><figcaption>Keywords</figcaption></figure></div><div style="text-align:center;"><figure><img src="images/table.png" name="Table"><figcaption>Table</figcaption></figure></div><div style="text-align:center;"><figure><img src="images/list.png" name="List"><figcaption>List</figcaption></figure></div><div style="text-align:center;"><figure><img src="images/Codeblock.png" name="Codeblock"><figcaption>Codeblock</figcaption></figure></div><p> Ao introduzir estes quatro estados no Flex, conseguimos facilitar um pouco o nosso trabalho. No caso do codeblock, interessa-nos ter um estado porque isso nos permite guardar todo o que está dentro das etiquetas respectivas, inclusive outras etiquetas. Dentro do codeblock podemos fazer um BEGIN de outro tipo, sem compremeter o principal objectivo, que é colocar tudo o que está lá em formato de código. Para criar as tabelas, poupa-nos algum trabalho. Depois em relação aos estados list e keywords, que são muito parecidos, usamos estados porque assim basta inserir cada elemento da lista por linha sem precisar de usar algum tipo de separador, o que torna a nossa linguagem mai prática. Além de estados, o restante \textit{Flex} é bastante simples e intuitivo pois são apenas as etiquetas que nós definimos para a nossa linguagem. Como por exemplo, este exerto inicial: </p><div class="example"><p><pre>begin_report "BREPORT"
			}</pre></p></div><hr><h1><a name="Utilização do YACC">Utilização do YACC</a></h1><p> Aqui encontrar-se-ão referenciados todos os tokens deinidos na especificação FLEX e estes serão palavras reservadas da nossa própria linguagem. Cada token terá uma tarefa específicaca quanto ao processamento da linguagem em uso uma vez que cada palavra indica um tipo de instrucão diferente. </p><p> Aqui é efetuada uma tradução direta entre os símbolos definidos na gramática apresentada e o código C. É desta forma que guardamos na estrutura de dados todo o conteúdo relevante e que nos permite gerar relatórios tanto em LaTeX como em HTML. Ao utilizar o YACC podemos definir código C a ser exucutado no momento em que cada regra da gramática definida é verificada.  </p><hr><h1><a name="Estruturas na linguagem C">Estruturas na linguagem C</a></h1><p> A utilização de Unions facilitou o processo de criação da linguagem e de facilitação do uso . A razão principal para o uso deste tipo de estruturas é a possibilidade de representar uma informação de mais do que uma maneira. Como é o caso da nossa linguagem, em que, por exemplo, um capítulo pode conter vários topos de elementos. Resta falar do uso da biblioteca do C, que foi recomendada pelos docentes, a glib. No primeiro trabalho prático, usamos módulos de listas ligadas feitos por nós e agora escolhemos usar esta biblioteca, e também porque nunca nenhum de nós tinha experimentado. Fica de notar que facilitou o processo, comparativamente a trabalhos anteriores, e será concerteza usada por nós futuro.   </p><hr><h1><a name="Geração de Relatórios - Latex e Html">Geração de Relatórios - Latex e Html</a></h1><p> Depois de escrita toda a gramática e definidas todas as nossas tags a usar. Fica a faltar gerar, com o recurso à linguagem C, um relatório em HTML. Todas a nossas funções que imprimem o HTML foram feitas no ficheiro  <b>funcs.c.</b> Nós optamos por dividir e minimizar ao máximo a complexidade das funções para posteriormente ser mais fácil resolver algum problema. Deste modo, evitamos a implementação de funções demasiado grandes. Fazendo a ligação das tags ao HTML, através da nossa linguagem decidimos o que gerar conforme o que definimos. A maioria das coisas já existiam no HTML, mas por exemplo para os índices não existe nada que os criem automaticamente.  </p><table border=2 class="selectorsReview" style="margin-left:auto; margin-right:auto; padding-top:25px;padding-bottom:25px;"><tr><td>Dados</td><td>Mais dados</td><td>Teste</td></tr><tr><td>MAIS dados</td><td>TESTE</td><td>TESTE2</td></tr><tr><td>AINDA mais dados</td><td>variar</td><td>ok</td></tr><tr><td>amostra</td><td>amostra2</td><td>amostra4</td></tr><caption><a name="Exemplo de uma tabela gerada.">Exemplo de uma tabela gerada.</a></caption></table><p> Exemplo de uma referência <a href=http://"www.uminho.pt">www.uminho.pt</a></p><hr><h1><a name="Makefile e Manpage">Makefile e Manpage</a></h1><p> Para facilitar o processo de gestão quer de desenvolvimento quer de distribuição do software desenvolvido, seguimos os conselhos dos docentes e criamos um makefile com as funções mais comuns, tentado seguir os standards quer de nomenclatura quer das funcionalidades.Assim sendo criamos 4 opções mais distintas no makefile: install, clean, test e delete. </p><p> Em relação à opção  <i>install</i> , o que a sequência de comandos por nós definida faz é: compilar os ficheiros .c por ordem de dependência, fazer a linkagem, mover o escutável para a directoria /usr/bin e mover o ficheiro da man page para a directoria dos manuais. Além disso remove os ficeiros .o gerados durante o processo. </p><p> A opção delete executa a seguinte sequência: eliminar o executável e o ficheiro da man page. </p><p> A opção test corre corre o executável na diretoria atual utilizando como input um ficheiro que aparece na raiz da diretoria que contem os ficheiros com o código. </p><p> A opção delete limpa a raiz da directoria alguns ficheiros que o compilador gera que que não interessam, com por exemplo o lex.yy.c, y.tab.c e o y.tab.h. </p><p> Mais uma sugestão dada pelos docentes passava por criar uma manpage. Como o executável que criamos não tem opções ao executar pela linha de comandos, o manual que criámos é relativamente pobre e contem apenas uma descrição do trabalho. Para desenvolver esta parte utilizamos a aplicação para Mac OSX Mandrake. </p><hr><h1><a name="Conclusão">Conclusão</a></h1><p> Em relação a este trabalho prático e após o seu término podemos retirar algumas conclusões: </p><ul><li>Este trabalho permitiu, de uma forma agradável, consolidar os conhecimentos adquiridos acerca do par FLEX/YACC para a geração de compiladores.</li><li>Olhando para o trabalho realizado, embora o resultado final seja uma linguagem funcional, verificamos que talvez com mais tempo pudéssemos gerar uma linguagem mais agradável para o utilizador.</li><li>Apesar de não termos implementado a geração de relatórios em \LaTeX, tal não seria muito díficil sendo o trabalho realizado análogo ao realizado para a geração de relatórios em HTML.</li></ul><hr><h2>Epilogue</h2><p><b>Este trabalho foi muito porreiro. Sem mais nada a acrescentar, estamos prontos para escrever relatórios.</b></p></body></html>